<!doctype html>
<html>
<head>
    <title>WinDivert 2.0 Documentation</title>
</head>
<body>
<h1>WinDivert 2.0: Windows Packet Divert</h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#building">2. Building</a></li>
<ul>
<li><a href="#driver_signing">2.1 Driver Signing</a></li>
</ul>
<li><a href="#installing">3. Installing</a></li>
<li><a href="#uninstalling">4. Uninstalling</a></li>
<li><a href="#programming_api">5. Programming API</a></li>
<ul>
<li><a href="#divert_layers">5.1 WINDIVERT_LAYER</a></li>
<li><a href="#divert_address">5.2 WINDIVERT_ADDRESS</a></li>
<li><a href="#divert_open">5.3 WinDivertOpen</a></li>
<li><a href="#divert_recv">5.4 WinDivertRecv</a></li>
<li><a href="#divert_recv_ex">5.5 WinDivertRecvEx</a></li>
<li><a href="#divert_send">5.6 WinDivertSend</a></li>
<li><a href="#divert_send_ex">5.7 WinDivertSendEx</a></li>
<li><a href="#divert_shutdown">5.8 WinDivertShutdown</a></li>
<li><a href="#divert_close">5.9 WinDivertClose</a></li>
<li><a href="#divert_set_param">5.10 WinDivertSetParam</a></li>
<li><a href="#divert_get_param">5.11 WinDivertGetParam</a></li>
</ul>
<li><a href="#helper_programming_api">6. Helper Programming API</a></li>
<ul>
<li><a href="#divert_iphdr">6.1 WINDIVERT_IPHDR</a></li>
<li><a href="#divert_ipv6hdr">6.2 WINDIVERT_IPV6HDR</a></li>
<li><a href="#divert_icmphdr">6.3 WINDIVERT_ICMPHDR</a></li>
<li><a href="#divert_icmpv6hdr">6.4 WINDIVERT_ICMPV6HDR</a></li>
<li><a href="#divert_tcphdr">6.5 WINDIVERT_TCPHDR</a></li>
<li><a href="#divert_udphdr">6.6 WINDIVERT_UDPHDR</a></li>
<li><a href="#divert_helper_parse_packet">6.7 WinDivertHelperParsePacket</a></li>
<li><a href="#divert_helper_hash_packet">6.8 WinDivertHelperHashPacket</a></li>
<li><a href="#divert_helper_parse_ipv4_address">6.9 WinDivertHelperParseIPv4Address</li>
<li><a href="#divert_helper_parse_ipv6_address">6.10 WinDivertHelperParseIPv6Address</li>
<li><a href="#divert_helper_format_ipv4_address">6.11 WinDivertHelperFormatIPv4Address</li>
<li><a href="#divert_helper_format_ipv6_address">6.12 WinDivertHelperFormatIPv6Address</li>
<li><a href="#divert_helper_calc_checksums">6.13 WinDivertHelperCalcChecksums</a></li>
<li><a href="#divert_helper_compile_filter">6.14 WinDivertHelperCompileFilter</a></li>
<li><a href="#divert_helper_eval_filter">6.15 WinDivertHelperEvalFilter</a></li>
<li><a href="#divert_helper_format_filter">6.16 WinDivertHelperFormatFilter</a></li>
<li><a href="#divert_helper_ntoh"><h3>6.17 WinDivertHelperNtoh*</a></li>
<li><a href="#divert_helper_hton"><h3>6.18 WinDivertHelperHton*</a></li>
</ul>
<li><a href="#filter_language">7. Filter Language</a></li>
<ul>
<li><a href="#filter_examples">7.1 Filter Examples</a></li>
<li><a href="#filter_usage">7.2 Filter Usage</a></li>
</ul>
<li><a href="#samples">8. Samples</a></li>
<li><a href="#known_issues">9. Known Issues</a></li>
<li><a href="#license">10. License</a></li>
</ul>

<hr>
<a name="introduction"><h2>1. Introduction</h2></a>
<p>
WinDivert is a user-mode 
capture/sniffing/modification/blocking/re-injection package for
Windows Vista, Windows Server 2008, Windows 7, and Windows 8.
WinDivert can be used to implement user-mode packet filters, packet sniffers,
firewalls, NAT, VPNs, tunneling applications, etc., without the need to
write kernel-mode code.
</p>
<p>
The main features of the WinDivert are:
<ul>
<li> User-mode packet capture, sniffing, dropping, filtering, modification,
     re-injection, etc.</li>
<li> Simple, high-level, programming API.</li>
<li> Fully documented with sample programs.</li>
<li> Full IPv6 support.</li>
<li> Full loopback (localhost) support.</li>
<li> A modern WDF/WFP driver implementation.</li>
<li> Open source; Licensed under GNU Lesser General Public License (LGPL)
     version 3.
     See the <a href="#license">License</a> for more information.</li>
</ul>
</p><p>
WinDivert provides similar functionality to
<tt>divert</tt> sockets from FreeBSD/MacOS, <tt>NETLINK</tt> sockets from
Linux, and some commercial packages such as <tt>WinPkFilter</tt> for Windows.
WinDivert also supports passive packet sniffing similar to <tt>Winpcap</tt>.
</p>

<hr>
<a name="building"><h2>2. Building</h2></a>
<p>
Note that pre-built WinDivert binary distributions are available from the
<a href="https://reqrypt.org/windivert.html">WinDivert website</a>.
Most users do not need to build their own version of WinDivert from source.
</p>
<p>
The source code for WinDivert is available for download at
<blockquote>
<a href="https://github.com/basil00/Divert">
    https://github.com/basil00/Divert</a>
</blockquote>
To build the WinDivert drivers from source:
<ol>
<li> Download and install <a href="http://www.microsoft.com/whdc/devtools/wdk/default.mspx">
Windows Driver Kit 7.1.0</a>.</li>
<li> Open a <i>x86 Free Build Environment</i> console.</li>
<li> In the WinDivert package root directory, run the command:
<pre>
wddk-build.bat
</pre>
This will build the <tt>install\WDDK\i386\WinDivert32.sys</tt> driver.</li>
<li> Next, open a <i>x64 Free Build Environment</i> console.</li>
<li> Re-run the <tt>wddk-build.bat</tt> command to build the
<tt>install\WDDK\amd64\WinDivert64.sys</tt> driver.</li>
</ol>
</p>
<p>
To build the WinDivert user-mode library (<tt>WinDivert.dll</tt>) and sample
programs:
<ol>
<li> First, build the WinDivert drivers by running the
<tt>wddk-build.bat</tt> command described above.</li>
<li> In Linux (with the MinGW cross-compilers installed) and in the
WinDivert package root directory, run the command:
<pre>
sh mingw-build.sh
</pre>
This will the user-mode library and sample programs which will be placed
in the <tt>install\MINGW</tt> subdirectory.</li>
</ol>
</p>
<p>
The generated <tt>WinDivert.dll</tt>/<tt>WinDivert.lib</tt> files
should be compatible with all major compilers, including both MinGW and
Visual Studio.
</p>

<a name="driver_signing"><h3>2.1 Driver Signing</h3></a>
<p>
If you built your own 
<tt>WinDivert32.sys</tt>/<tt>WinDivert64.sys</tt> drivers,
they must be digitally signed before they can be used.
See <a href="http://msdn.microsoft.com/en-us/windows/hardware/gg487317.aspx">Driver Signing Requirements for Windows</a>
for more information.
</p>
<p>
Note that the pre-built <tt>WinDivert32.sys</tt>/<tt>WinDivert64.sys</tt>
drivers from the official WinDivert distribution are already digitally signed.
</p>

<hr>
<a name="installing"><h2>3. Installing</h2></a>
<p>
WinDivert does not require any special installation.
Depending on your target configuration, simply place the following files in
your application's home directory:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Application Type
</th>
<th>
Target Windows Type
</th>
<th>
Files Required
</th>
</tr>
<tr>
<td>
32-bit
</td>
<td>
32-bit Windows only
</td>
<td>
<tt>WinDivert.dll</tt> (32-bit version) and <tt>WinDivert32.sys</tt>
</td>
</tr>
<tr>
<td>
64-bit
</td>
<td>
64-bit Windows only
</td>
<td>
<tt>WinDivert.dll</tt> (64-bit version) and <tt>WinDivert64.sys</tt>
</td>
</tr>
<tr>
<td>
32-bit
</td>
<td>
Both 32-bit and 64-bit Windows
</td>
<td>
<tt>WinDivert.dll</tt> (32-bit version), <tt>WinDivert32.sys</tt>,
    and <tt>WinDivert64.sys</tt>
</td>
</tr>
</table>
</center>
<p>
The WinDivert driver is automatically (and silently) installed on demand
whenever your application calls
<a href="#divert_open"><tt>WinDivertOpen()</tt></a>.
The calling application must have Administrator privileges.
</p>

<hr>
<a name="uninstalling"><h2>4. Uninstalling</h2></a>
<p>
To uninstall, simply delete the <tt>WinDivert.dll</tt>,
<tt>WinDivert32.sys</tt>, and <tt>WinDivert64.sys</tt> files.
If already running, the WinDivert driver will be automatically
uninstalled during the next machine reboot.
The WinDivert driver can also be manually removed by issuing the following
commands at the command prompt
<pre>
sc stop WinDivert2.0
sc delete WinDivert2.0
</pre>
Note that this is not recommended as it will interfere with other
applications that depend on WinDivert.
</p>

<hr>
<a name="programming_api"><h2>5. Programming API</h2></a>
<p>
To use the WinDivert package, a program/application must:
<ol>
<li> Include the <tt>windivert.h</tt> header file
<pre>
#include "windivert.h"
</pre></li>
<li> Link against or dynamically load the <tt>WinDivert.dll</tt> dynamic link
library.</li>
</ol>

<a name="divert_layers"><h3>5.1 WINDIVERT_LAYER</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef enum
{
    WINDIVERT_LAYER_NETWORK = 0,
    WINDIVERT_LAYER_NETWORK_FORWARD,
    WINDIVERT_LAYER_FLOW,
    WINDIVERT_LAYER_SOCKET,
    WINDIVERT_LAYER_REFLECT,
} <b>WINDIVERT_LAYER</b>, *<b>PWINDIVERT_LAYER</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Remarks</b><br>
<p>
WinDivert supports several <i>layers</i> for diverting or capturing
network packets/events.
Each layer has its own capabilities, such as the ability to block
events or to inject new events, etc.
The list of supported WinDivert layers is summarized below:
</p>
<p>
<center>
<table border="1" cellpadding="5">
<tr>
<th>Layer</th>
<th colspan="4">Capability</th>
<th>Description</th>
</tr>
<tr>
<th>
</th>
<th>
Block?
</th>
<th>
Inject?
</th>
<th>
Data?
</th>
<th>
PID?
</th>
<th>
</th>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_NETWORK</tt>
</td>
<td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td>
<td>
Network packets to/from the local machine.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_NETWORK_FORWARD</tt>
</td>
<td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td>
<td>
Network packets passing through the local machine.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_FLOW</tt>
</td>
<td></td><td></td><td></td><td>&#10004;</td>
<td>
Network flow established/deleted events.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_SOCKET</tt>
</td>
<td>&#10004;</td><td></td><td></td><td>&#10004;</td>
<td>
Socket operation events.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_REFLECT</tt>
</td>
<td></td><td></td><td>&#10004;</td><td>&#10004;</td>
<td>
WinDivert handle events.
</td>
</tr>
</table>
</center>
</p>
<p>
Here, the layer capabilities are:
</p>
<ul>
<li> (Block?) the layer can block events/packets;</li>
<li> (Inject?) the layer can inject new events/packets;</li>
<li> (Data?) whether the layer returns packet data or not; and</li>
<li> (PID?) whether the ID for the process associated with
     an event/packet is available at this layer, or not.
</ul>
<p>
The <tt>WINDIVERT_LAYER_NETWORK</tt> (and
<tt>WINDIVERT_LAYER_NETWORK_FORWARD</tt>) layers
allow the user application to capture/block/inject network packets passing
to/from (and through) the local machine.
These represent the <q>traditional</q>
WinDivert layers.
Only a single event is supported:
</p>
<ul>
<li> <tt>WINDIVERT_EVENT_NETWORK_PACKET</tt>: A new network packet was
    intercepted.</li>
</ul>
Due to technical limitations, process ID information is not available
at these layers.
<p>
The <tt>WINDIVERT_LAYER_FLOW</tt> layer captures information about
network flow establishment/deletion events.
Here, a <i>flow</i> represents either (1) a
TCP connection, or (2) an implicit <q>flow</q> created by the first
sent/received packet for non-TCP traffic, e.g., UDP.
The <tt>WINDIVERT_LAYER_FLOW</tt> layer supports two events:
</p>
<ul>
<li> <tt>WINDIVERT_EVENT_FLOW_ESTABLISHED</tt>: A new flow is created.</li>
<li> <tt>WINDIVERT_EVENT_FLOW_DELETED</tt>: An old flow is deleted.</li>
</ul>
<p>
Old flows are deleted when the corresponding connection is closed (for TCP),
or on a timeout (non-TCP).
Flow events can be captured, but never blocked or injected.
Process ID information is available at this layer.
Due to technical limitations, the
<tt>WINDIVERT_LAYER_FLOW</tt> layer cannot capture events that
occurred before the WinDivert handle was opened.
</p>
<p>
The <tt>WINDIVERT_LAYER_SOCKET</tt> layer captures/blocks events that
correspond to socket operations, such as:
</p>
<ul>
<li> <tt>WINDIVERT_EVENT_SOCKET_BIND</tt>: A <tt>bind()</tt> operation.</li>
<li> <tt>WINDIVERT_EVENT_SOCKET_LISTEN</tt>: A <tt>listen()</tt> operation.</li>
<li> <tt>WINDIVERT_EVENT_SOCKET_CONNECT</tt>: A <tt>connect()</tt>
    operation.</li>
<li> <tt>WINDIVERT_EVENT_SOCKET_ACCEPT</tt>: An <tt>accept()</tt>
    operation.</li>
</ul>
<p>
Socket events can be blocked but not injected.
Process ID information is available at this layer.
Due to technical limitations, the
<tt>WINDIVERT_LAYER_SOCKET</tt> layer cannot capture events that
occurred before the WinDivert handle was opened.
</p>
<p>
Finally, the <tt>WINDIVERT_LAYER_REFLECT</tt> layer captures events related
to WinDivert itself, such as:
</p>
<ul>
<li> <tt>WINDIVERT_EVENT_REFLECT_OPEN</tt>: A new WinDivert handle was
    opened.</li>
<li> <tt>WINDIVERT_EVENT_REFLECT_CLOSE</tt>: An old WinDivert handle was
    closed.</li>
</ul>
<p>
These events can be captured, but not injected nor blocked.
Process ID information is available at this layer,
meaning that it is possible to determine which (if any) process is using
WinDivert.
The layer also returns a <q>pseudo packet</q> that encodes the filter string
associated with the event.
The <tt>WINDIVERT_LAYER_REFLECT</tt> layer can also capture events that
occurred before the handle was opened.
</p>
</dd></dl>

<a name="divert_address"><h3>5.2 WINDIVERT_ADDRESS</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT32 IfIdx;
    UINT32 SubIfIdx;
} <b>WINDIVERT_DATA_NETWORK</b>, *<b>PWINDIVERT_DATA_NETWORK</b>;

typedef struct
{
    UINT32 ProcessId;
    UINT32 LocalAddr[4];
    UINT32 RemoteAddr[4];
    UINT16 LocalPort;
    UINT16 RemotePort;
    UINT8  Protocol;
} <b>WINDIVERT_DATA_FLOW</b>, *<b>PWINDIVERT_DATA_FLOW</b>;

typedef struct
{
    UINT32 ProcessId;
    UINT32 LocalAddr[4];
    UINT32 RemoteAddr[4];
    UINT16 LocalPort;
    UINT16 RemotePort;
    UINT8  Protocol;
} <b>WINDIVERT_DATA_SOCKET</b>, *<b>PWINDIVERT_DATA_SOCKET</b>;

typedef struct
{
    INT64  Timestamp;
    UINT32 ProcessId;
    WINDIVERT_LAYER Layer;
    UINT64 Flags;
    INT16  Priority;
} <b>WINDIVERT_DATA_REFLECT</b>, *<b>PWINDIVERT_DATA_REFLECT</b>;

typedef struct
{
    INT64  Timestamp;
    UINT64 Layer:8;
    UINT64 Event:8;
    UINT64 Outbound:1;
    UINT64 Loopback:1;
    UINT64 Impostor:1;
    UINT64 IPv6:1;
    UINT64 PseudoIPChecksum:1;
    UINT64 PseudoTCPChecksum:1;
    UINT64 PseudoUDPChecksum:1;
    union
    {
        WINDIVERT_DATA_NETWORK Network;
        WINDIVERT_DATA_FLOW    Flow;
        WINDIVERT_DATA_SOCKET  Socket;
        WINDIVERT_DATA_REFLECT Reflect;
    };
} <b>WINDIVERT_ADDRESS</b>, *<b>PWINDIVERT_ADDRESS</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b>
<ul>
<li> <tt>Timestamp</tt>: A timestamp indicating when event occurred.</li>
<li> <tt>Layer</tt>: The handle's layer (<tt>WINDIVERT_LAYER_*</tt>).</li>
<li> <tt>Event</tt>: The captured event (<tt>WINDIVERT_EVENT_*</tt>).</li>
<li> <tt>Outbound</tt>: Set to <tt>1</tt> for <i>outbound</i>
    packets/event, <tt>0</tt> for <i>inbound</i> or otherwise.</li>
<li> <tt>Loopback</tt>: Set to <tt>1</tt> for loopback packets, <tt>0</tt>
otherwise</li>
<li> <tt>Impostor</tt>: Set to <tt>1</tt> for <q>impostor</q> packets,
<tt>0</tt> otherwise.</li>
<li> <tt>IPv6</tt>: Set to <tt>1</tt> for IPv6 packets/events, <tt>0</tt>
otherwise</li>
<li> <tt>PseudoIPChecksum</tt>: Set to <tt>1</tt> for packets with a
<i>pseudo</i> IPv4 checksum, <tt>0</tt> otherwise.</li>
<li> <tt>PseudoTCPChecksum</tt>: Set to <tt>1</tt> for packets with a
<i>pseudo</i> TCP checksum, <tt>0</tt> otherwise.</li>
<li> <tt>PseudoTCPChecksum</tt>: Set to <tt>1</tt> for packets with a
<i>pseudo</i> UDP checksum, <tt>0</tt> otherwise.</li>
<li> <tt>Network.IfIdx</tt>: The interface index on which the packet arrived
    (for inbound packets), or is to be sent (for outbound packets).</li>
<li> <tt>Network.SubIfIdx</tt>: The sub-interface index for <tt>IfIdx</tt>.</li>
<li> <tt>Flow.ProcessId</tt>: The ID of the process associated with the
    flow.</li>
<li> <tt>Flow.LocalAddr</tt>, <tt>Flow.RemoteAddr</tt>,
     <tt>Flow.LocalPort</tt>, <tt>Flow.RemotePort</tt>, and
     <tt>Flow.Protocol</tt>: The network 5-tuple associated with the
     flow.</li>
<li> <tt>Socket.ProcessId</tt>: The ID of the process associated with the
     socket operation.</li>
<li> <tt>Socket.LocalAddr</tt>, <tt>Socket.RemoteAddr</tt>,
     <tt>Socket.LocalPort</tt>, <tt>Socket.RemotePort</tt>, and
     <tt>Socket.Protocol</tt>: The network 5-tuple associated with the
     socket operation.</li>
<li> <tt>Reflect.Timestamp</tt>: A timestamp indicating when the handle was 
     opened.</li>
<li> <tt>Reflect.ProcessId</tt>: The ID of the process that opened the
     handle.</li>
<li> <tt>Reflect.Layer</tt>, <tt>Reflect.Flags</tt>, and
     <tt>Reflect.Priority</tt>: The
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a> parameters of
     the opened handle.</li>
</ul>
</p><p>
<b>Remarks</b><br>
The <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> structure
represents the "address" of a captured or injected packet.
The address includes the packet's timestamp, layer, event, flags, and
layer-specific data.
All fields are set by <a href="#divert_recv"><tt>WinDivertRecv()</tt></a>
when the packet/event is captured.
Only some fields are used by
<a href="#divert_send"><tt>WinDivertSend()</tt></a> when a packet
is injected.
</p><p>
The <tt>Timestamp</tt> indicates when the packet/event was first
captured by WinDivert.
It uses the same clock as
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644904(v=vs.85).aspx"><tt>QueryPerformanceCounter()</tt></a>.
</p><p>
The <tt>Layer</tt> indicates the <i>layer</i> parameter
(<a href="#divert_layers"><tt>WINDIVERT_LAYER_*</tt></a>) that was passed to
<a href="#divert_open"><tt>WinDivertOpen()</tt></a>.
It is included in the address to make the structure self-contained.
</p><p>
The <tt>Event</tt> indicates the layer-specific <i>event</i>
(<a href="#divert_layers"><tt>WINDIVERT_EVENT_*</tt></a>) that was captured.
</p><p>
The <tt>Outbound</tt> flag is set for <i>outbound</i>
packets/events, and is cleared
for <i>inbound</i> or direction-less packets/events.
</p><p>
The <tt>Loopback</tt> flag is set for <i>loopback</i> packets.
Note that Windows considers any packet originating from, and destined to, the
current machine to be a loopback packet, so loopback packets are not
limited to localhost addresses.
Note that WinDivert considers loopback packets to be
<i>outbound only</i>, and will not capture loopback packets on the
inbound path.
</p><p>
The <tt>Impostor</tt> flag is set for <i>impostor</i> packets.
An impostor packet is any packet injected by another driver rather than
originating from the network or Windows TCP/IP stack.
Impostor packets are problematic since they can cause infinite loops,
where a packet injected by <a href="#divert_send"><tt>WinDivertSend()</tt></a> 
is captured again by <a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
For more information, see <a href="#divert_send"><tt>WinDivertSend()</tt></a>.
</p><p>
The <tt>IPv6</tt> flag is set for <i>IPv6</i> packets/events, and cleared
for <i>IPv4</i> packets/events.
</p><p>
The <tt>Pseudo*Checksum</tt> flags indicate whether the packet uses
<i>full</i> or <i>pseudo</i> checksums.
Pseudo checksums are used when 
<i>IP/TCP/UDP checksum offloading</i> is enabled, meaning that the network
hardware calculates/validates checksums rather than the Windows TCP/IP stack.
Pseudo checksums may be arbitrary values.
Typically, modified packets should preserve the <tt>Pseudo*Checksum</tt> flags.
</p><p>
The <tt>Network.*</tt> fields are only valid at the
<tt>WINDIVERT_LAYER_NETWORK</tt> and
<tt>WINDIVERT_LAYER_NETWORK_FORWARD</tt> layers.
The <tt>Network.IfIdx</tt>/<tt>Network.SubIfIdx</tt> indicate the packet's
network adapter (a.k.a. interface) index.
These values are ignored for <i>outbound</i> packets.
</p><p>
The <tt>Flow.*</tt> fields are only valid at the
<tt>WINDIVERT_LAYER_FLOW</tt> layer.
The <tt>Flow.ProcessId</tt> is the <i>ID</i> of the process that
created the flow (for outbound), or receives the flow (for inbound).
The
(<tt>Flow.LocalAddr</tt>, <tt>Flow.LocalPort</tt>,
 <tt>Flow.RemoteAddr</tt>, <tt>Flow.RemotePort</tt>, <tt>Flow.Protocol</tt>)
fields form the network 5-tuple associated with the flow.
For IPv4, the <tt>Flow.LocalAddr</tt> and <tt>Flow.RemoteAddr</tt>
fields will be IPv4-mapped IPv6 addresses,
e.g. the IPv4 address <tt>X.Y.Z.W</tt> will be represented by
<tt>::ffff:X.Y.Z.W</tt>.
</p><p>
The <tt>Socket.*</tt> fields are only valid at the
<tt>WINDIVERT_LAYER_SOCKET</tt> layer.
The <tt>Socket.ProcessId</tt> is the <i>ID</i> of the process that executed
the socket operation.
The
(<tt>Socket.LocalAddr</tt>, <tt>Socket.LocalPort</tt>,
 <tt>Socket.RemoteAddr</tt>, <tt>Socket.RemotePort</tt>,
 <tt>Socket.Protocol</tt>)
fields form the network 5-tuple associated with the operation.
For IPv4, the <tt>Socket.LocalAddr</tt> and <tt>Socket.RemoteAddr</tt>
fields will be IPv4-mapped IPv6 addresses.
The <tt>WINDIVERT_EVENT_SOCKET_BIND</tt> and
<tt>WINDIVERT_EVENT_SOCKET_LISTEN</tt> events will occur before a
connection attempt has been made, meaning that the
<tt>Socket.RemoteAddr</tt> and <tt>Socket.RemotePort</tt> fields
for these events will be zero.
</p><p>
The <tt>Reflect.*</tt> fields are only valid at the
<tt>WINDIVERT_LAYER_REFLECT</tt> layer.
The <tt>Reflect.ProcessId</tt> is the <i>ID</i> of the process that
opened the WinDivert handle.
The <tt>Reflect.Timestamp</tt> field is a timestamp indicating when the
handle was opened, using
the same clock as
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644904(v=vs.85).aspx"><tt>QueryPerformanceCounter()</tt></a>.
The <tt>Reflect.Layer</tt>, <tt>Reflect.Flags</tt>, and
    <tt>Reflect.Priority</tt> fields correspond to the
<a href="#divert_open"><tt>WinDivertOpen()</tt></a> parameters of
the opened handle.
</p><p>
Most address fields are ignored by
<a href="#divert_send"><tt>WinDivertSend()</tt></a>.
The exceptions are
<tt>Outbound</tt> (for <tt>WINDIVERT_LAYER_NETWORK</tt> only),
<tt>Impostor</tt>, <tt>PseudoIPChecksum</tt>, <tt>PseudoTCPChecksum</tt>,
<tt>PseudoUDPChecksum</tt>, <tt>Network.IfIdx</tt> and
<tt>Network.SubIfIdx</tt>.
</p>
</dd></dl>

<a name="divert_open"><h3>5.3 WinDivertOpen</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
HANDLE <b>WinDivertOpen</b>(
    __in const char *filter,
    __in WINDIVERT_LAYER layer,
    __in INT16 priority,
    __in UINT64 flags
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>filter</tt>: A packet filter string specified in the WinDivert
    <a href="#filter_language">filter language</a>.</li>
<li> <tt>layer</tt>: The layer.</li>
<li> <tt>priority</tt>: The priority of the handle.</li>
<li> <tt>flags</tt>: Additional flags.</li>
</ul>
</p><p>
<b>Return Value</b><br>
A valid WinDivert handle on success, or
<tt>INVALID_HANDLE_VALUE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
Common errors include:
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Name
</th>
<th>
Code
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<tt>ERROR_FILE_NOT_FOUND</tt>
</td>
<td>
2
</td>
<td>
The driver files
<tt>WinDivert32.sys</tt> or <tt>WinDivert64.sys</tt>
were not found.
</td>
</tr>
<tr>
<td>
<tt>ERROR_ACCESS_DENIED</tt>
</td>
<td>
5
</td>
<td>
The calling application does not have Administrator privileges.
</td>
</tr>
<tr>
<td>
<tt>ERROR_INVALID_PARAMETER</tt>
</td>
<td>
87
</td>
<td>
This indicates an invalid packet filter string, layer, priority, or flags.
</td>
</tr>
<tr>
<td>
<tt>ERROR_INVALID_IMAGE_HASH</tt>
</td>
<td>
577
</td>
<td>
The <tt>WinDivert32.sys</tt> or <tt>WinDivert64.sys</tt> driver does not
have a valid digital signature
(see the <a href="#driver_signing">driver signing requirements</a> above).
</td>
</tr>
<tr>
<td>
<tt>ERROR_SERVICE_DOES_NOT_EXIST</tt>
</td>
<td>
1060
</td>
<td>
The handle was opened with the <tt>WINDIVERT_FLAG_NO_INSTALL</tt> flag and
the WinDivert driver is not already installed.
</td>
</tr>
<tr>
<td>
<tt>ERROR_DRIVER_BLOCKED</tt>
</td>
<td>
1275
</td>
<td>
This error occurs for various reasons, including:
<ol>
<li> the WinDivert driver is blocked by security software; or</li>
<li> you are using a virtualization environment that does not support
drivers.</li>
</ol>
</td>
</tr>
<tr>
<td>
<tt>EPT_S_NOT_REGISTERED</tt>
</td>
<td>
1753
</td>
<td>
This error occurs when the <i>Base Filtering Engine</i> service has been
disabled.
</td>
</tr>
</table>
</center>
</p><p>
<b>Remarks</b><br>
Opens a WinDivert handle for the given filter.
Unless otherwise specified by <tt>flags</tt>, any packet or event that
matches the filter will be diverted to the handle.
Diverted packets/events can be read by the application with
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
</p>
<p>
A typical application is only interested in a subset of all network traffic
or events.
In this case the filter should <i>match as closely as possible</i> to
the subset of interest.
This avoids unnecessary overheads introduced by diverting packets to the
user-mode application.
See the <a href="#filter_language">filter language</a> section for more
information.
</p>
<p>
The <i>layer</i> of the WinDivert handle is determined by the <tt>layer</tt>
parameter.
See <a href="#divert_layers"><tt>WINDIVERT_LAYER</tt></a> for more
information.
Currently the following layers are supported:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Layer
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_NETWORK = 0</tt>
</td>
<td>
Network packets to/from the local machine.
This is the default layer.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_NETWORK_FORWARD</tt>
</td>
<td>
Network packets passing through the local machine.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_FLOW</tt>
</td>
<td>
Network flow established/deleted events.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_SOCKET</tt>
</td>
<td>
Socket operation events.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_REFLECT</tt>
</td>
<td>
WinDivert handle events.
</td>
</tr>
</table>
</center>
<p>
Different WinDivert handles can be assigned different priorities by the
<tt>priority</tt> parameter.
Packets are diverted to higher priority handles before lower priority
handles.
Packets injected by a handle are then diverted to the next priority handle,
and so on, provided the packet matches the handle's filter.
A packet is only diverted once per priority level, so handles should not
share priority levels unless they use mutually exclusive filters.
Otherwise it is not defined which handle will receive the packet first.
Lower <tt>priority</tt> values represent higher priorities, with
<tt>-30000</tt> being the highest priority, <tt>0</tt> the middle
(and a good default) priority, and <tt>30000</tt> the lowest priority.
</p>
<p>
Different flags affect how the opened handle behaves.
The following flags are supported:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Flag
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_SNIFF</tt>
</td>
<td>
This flag opens the WinDivert handle in <i>packet sniffing</i> mode.
In packet sniffing mode the original packet is not dropped-and-diverted
(the default) but copied-and-diverted.
This mode is useful for implementing packet sniffing tools similar to those
applications that currently use <tt>Winpcap</tt>.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_DROP</tt>
</td>
<td>
This flag indicates that the user application does not intend to read matching
packets with <a href="#divert_recv"><tt>WinDivertRecv()</tt></a>, instead the
packets should be silently dropped.
This is useful for implementing simple packet filters using the
WinDivert <a href="#filter_language">filter language</a>.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_RECV_ONLY</tt>
</td>
<td>
This flags forces the handle into <q>receive only</q> mode which effectively
disables <a href="#divert_send"><tt>WinDivertSend()</tt></a>.
This means that it is possible to block/capture packets or events but not
inject them.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_READ_ONLY</tt>
</td>
<td>
An alias for <tt>WINDIVERT_FLAG_RECV_ONLY</tt>.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_SEND_ONLY</tt>
</td>
<td>
This flags forces the handle into <q>send only</q> mode which effectively
disables <a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
This means that it is possible to inject packets or events, but not
block/capture them.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_WRITE_ONLY</tt>
</td>
<td>
An alias for <tt>WINDIVERT_FLAG_SEND_ONLY</tt>.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_FLAG_RECV_PARTIAL</tt>
</td>
<td>
This flags enables <q>partial receives</q>.
By default, if a packet is too big for the buffer passed to
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>, the operation
will fail with <tt>ERROR_INSUFFICIENT_BUFFER</tt>.
This flag silences this error and only copies part of the packet
up to the buffer size.
The <tt>WINDIVERT_FLAG_RECV_PARTIAL</tt> behavior was the default
on older (pre-2.0) versions of WinDivert.
</td>
</tr>
<td>
<tt>WINDIVERT_FLAG_NO_INSTALL</tt>
</td>
<td>
This flags causes <tt>WinDivertOpen()</tt> to fail with 
<tt>ERROR_SERVICE_DOES_NOT_EXIST</tt> if the WinDivert driver
is not already installed.
This flag is useful for querying the WinDivert state using a
<tt>WINDIVERT_LAYER_REFLECT</tt> handle.
</td>
</tr>
</table>
</center>
<p>
Note that any combination of
<tt>(WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_DROP)</tt> or
<tt>(WINDIVERT_FLAG_RECV_ONLY | WINDIVERT_FLAG_SEND_ONLY)</tt> or
<tt>(WINDIVERT_FLAG_RECV_PARTIAL | WINDIVERT_FLAG_SEND_ONLY)</tt>
are considered invalid.
</p>
<p>
Some layers have mandatory flags, as listed below:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Layer
</th>
<th>
Required Flags
</th>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_FLOW</tt>
</td>
<td>
<tt>WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY</tt>
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_SOCKET</tt>
</td>
<td>
<tt>WINDIVERT_FLAG_RECV_ONLY</tt>
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_LAYER_REFLECT</tt>
</td>
<td>
<tt>WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY</tt>
</td>
</tr>
</table>
</center>
</dd></dl>

<a name="divert_recv"><h3>5.4 WinDivertRecv</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertRecv</b>(
    __in HANDLE handle,
    __out PVOID pPacket,
    __in UINT packetLen,
    __out_opt PWINDIVERT_ADDRESS pAddr,
    __out_opt UINT *recvLen
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>pPacket</tt>: A buffer for the captured packet.</li>
<li> <tt>packetLen</tt>: The length of the buffer <tt>pPacket</tt>.</li>
<li> <tt>pAddr</tt>: The
    <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> of the captured
    packet.</li>
<li> <tt>recvLen</tt>: The total number of bytes written to <tt>pPacket</tt>.
     Can be <tt>NULL</tt> if this information is not required.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if a packet was successfully received, or <tt>FALSE</tt> if
an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Receives a diverted packet that matched the filter passed to
<a href="#divert_open"><tt>WinDivertOpen()</tt></a>.
The received packet is guaranteed to match the filter.
</p><p>
The contents of the captured packet are written to <tt>pPacket</tt>.
If the captured packet is larger than the <tt>pPacket</tt> buffer length,
then the packet will be truncated.
If <tt>recvLen</tt> is non-<tt>NULL</tt>, then the total number of bytes
written to <tt>pPacket</tt> is placed there.
If non-<tt>NULL</tt>, the address of the captured packet is written to
<tt>pAddr</tt>.
</p><p>
An application should call <a href="#divert_recv"><tt>WinDivertRecv()</tt></a>
<i>as soon as possible</i>
after a successful call to <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.
When a WinDivert handle is open, any packet that matches the filter will
be captured and queued until handled by
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
Packets are not queued indefinitely, and if not handled in a timely manner,
any captured packet may be dropped.
The amount of time a packet is queued can be controlled with the
<a href="#divert_set_param"><tt>WinDivertSetParam()</tt></a> function.
</p><p>
Captured packets are guaranteed to have correct checksums, or
pseudo checksums, as indicated by the <tt>Pseudo*Checksum</tt> flags
from the <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a>.
</p><p>
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a> should not be used on any
WinDivert handle created with the <tt>WINDIVERT_FLAG_DROP</tt> set.
</p>
</dd></dl>

<a name="divert_recv_ex"><h3>5.5 WinDivertRecvEx</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertRecvEx</b>(
    __in HANDLE handle,
    __out VOID *pPacket,
    __in UINT packetLen,
    __out_opt UINT *recvLen,
    __in UINT64 flags,
    __out_opt WINDIVERT_ADDRESS *pAddr,
    __inout_opt UINT *pAddrLen,
    __inout_opt LPOVERLAPPED lpOverlapped
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>pPacket</tt>: A buffer for the captured packet(s).</li>
<li> <tt>packetLen</tt>: The length of the <tt>pPacket</tt> buffer in
    bytes.</li>
<li> <tt>recvLen</tt>: The total number of bytes written to <tt>pPacket</tt>.
     Can be <tt>NULL</tt> if this information is not required.</li>
<li> <tt>flags</tt>: Reserved, set to zero.</li>
<li> <tt>pAddr</tt>: The
    <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> of the captured
    packet(s).</li>
<li> <tt>pAddrLen</tt>: Initially, a pointer to the length of the
    <tt>pAddr</tt> buffer in bytes.
    This value is updated to the total bytes written to <tt>pAddr</tt>.
    If <tt>NULL</tt>, a fixed length of <tt>sizeof(WINDIVERT_ADDRESS)</tt> is
    assumed.</li>
<li> <tt>lpOverlapped</tt>: An optional pointer to a <tt>OVERLAPPED</tt>
     structure.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if a packet was successfully received, or <tt>FALSE</tt> 
otherwise.
Use <tt>GetLastError()</tt> to get the reason.
The error code <tt>ERROR_IO_PENDING</tt> indicates that the overlapped
operation has been successfully initiated and that completion will be
indicated at a later time.
All other codes indicate an error.
</p><p>
<b>Remarks</b><br>
This function is equivalent to
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a> except:
</p>
<ul>
<li> <i>Overlapped I/O</i> is supported via the <tt>lpOverlapped</tt>
    parameter.</li>
<li> <i>Batched I/O</i> (i.e., reading multiple packets at once) is
    supported.</li>
</ul>
<p>
Batched I/O makes it possible to receive multiple packets at once using a
single operation.
This reduces the number of kernel/user-mode context switches, improving
performance.
To use batched I/O, pass an array of more than one
<tt>WINDIVERT_ADDRESS</tt> to <tt>pAddr</tt>, set <tt>pAddrLen</tt>
to be the total length of the <tt>pAddr</tt> array, and ensure that
<tt>pPacket</tt> points to a sufficiently large buffer for multiple
packets.
When the operation completes, the value pointed to by <tt>pAddrLen</tt>
is updated to the total number of address bytes actually received.
For example, if a batch of <tt>5</tt> packets were to be received, then
<tt>pAddrLen</tt> will be updated to point to the value
<tt>(5*sizeof(WINDIVERT_ADDRESS))</tt>.
The received packets are packed continuously into the <tt>pPacket</tt> buffer
without gaps.
</dd></dl>

<a name="divert_send"><h3>5.6 WinDivertSend</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertSend</b>(
    __in HANDLE handle,
    __in PVOID pPacket,
    __in UINT packetLen,
    __in PWINDIVERT_ADDRESS pAddr,
    __out_opt UINT *sendLen
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>pPacket</tt>: A buffer containing the packet to be injected.</li>
<li> <tt>packetLen</tt>: The total length of the buffer <tt>pPacket</tt>.</li> 
<li> <tt>pAddr</tt>: The
    <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> for the injected
    packet.</li>
<li> <tt>sendLen</tt>: The total number of bytes injected.
     Can be <tt>NULL</tt> if this information is not required.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if a packet was successfully injected, or <tt>FALSE</tt> if
an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
Common errors include:
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Name
</th>
<th>
Code
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<tt>ERROR_HOST_UNREACHABLE</tt>
</td>
<td>
1232
</td>
<td>
This error occurs when an <i>impostor</i> packet (with
<tt>pAddr-&gt;Impostor</tt> set to <tt>1</tt>) is injected and the
<tt>ip.TTL</tt> or <tt>ipv6.HopLimit</tt> field goes to zero.
This is a defense of <q>last resort</q> against infinite loops caused by
impostor packets.
</td>
</tr>
</table>
</center>
</p><p>
Note that a return value of <tt>TRUE</tt> does not necessarily mean the
packet was accepted by the Windows TCP/IP stack.
For better error messages (at the cost of performance), pass the
<tt>WINDIVERT_FLAG_DEBUG</tt> flag to <a
href="#divert_open"><tt>WinDivertOpen()</tt></a>.
</p><p>
<b>Remarks</b><br>
Injects a packet into the network stack.
The injected packet may be one received from
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>, or a
modified version, or a completely new packet.
Injected packets can be captured and diverted again by other WinDivert
handles with lower priorities.
</p><p>
The <tt>pAddr</tt> parameter determines how the packet is injected.
If the <tt>Direction</tt> field is <tt>WINDIVERT_DIRECTION_OUTBOUND</tt>,
the packet is injected into the <i>outbound</i> path (i.e. a packet leaving
this computer).
Else, if <tt>Direction</tt> is <tt>WINDIVERT_DIRECTION_INBOUND</tt>,
the packet is injected into the <i>inbound</i> path (i.e. a packet arriving at
this computer).
Note that the <tt>Direction</tt> field, and <i>not</i> the IP addresses in 
the injected packet, is used to determine the packet's direction.
</p><p>
For packets injected into the <i>inbound</i> path, the <tt>IfIdx</tt> and
<tt>SubIfIdx</tt> fields are assumed to contain valid interface numbers.
These may be retrieved from <a href="#divert_recv"><tt>WinDivertRecv()</tt></a>
(for packet modification),
or from the <a href="http://msdn.microsoft.com/en-us/library/aa366073%28v=VS.85%29.aspx">IP Helper API</a>.
</p><p>
For <i>outbound</i> injected packets, the <tt>IfIdx</tt> and <tt>SubIfIdx</tt>
fields are currently ignored and may be arbitrary values.
Injecting an inbound packet on the outbound path <i>may</i> work (for some
types of packets), however this should be considered "undocumented" behavior,
and may be changed in the future.
</p><p>
For <i>impostor</i> packets (where the <tt>Impostor</tt> field of
<tt>pAddr</tt> set to <tt>1</tt>) WinDivert will automatically decrement the
<tt>ip.TTL</tt> or <tt>ipv6.HopLimit</tt> fields for the injected packet.
This is to mitigate infinite loops since WinDivert cannot prevent
impostor packets from being captured again by
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
</p><p>
Injected packets must have the correct checksums.
Correct checksums can be calculated using the
<a
href="#divert_helper_calc_checksums"><tt>WinDivertHelperCalcChecksums()</tt></a>
function.
Note that packets returned by
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a> are 
guaranteed to have correct checksums.
</p>
<p>
When pseudo checksums are used,
the <a href="#divert_send"><tt>WinDivertSend()</tt></a> function may
modify the contents of the memory pointed to by the <tt>pPacket</tt> and
<tt>pAddr</tt> parameters.
Thus, it is important that this memory is not read-only.
</p>
</dd></dl>

<a name="divert_send_ex"><h3>5.7 WinDivertSendEx</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertSendEx</b>(
    __in HANDLE handle,
    __in PVOID pPacket,
    __in UINT packetLen,
    __in UINT64 flags,
    __in PWINDIVERT_ADDRESS pAddr,
    __out_opt UINT *sendLen,
    __inout_opt LPOVERLAPPED lpOverlapped
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>pPacket</tt>: A buffer containing the packet to be injected.</li>
<li> <tt>packetLen</tt>: The total length of the buffer <tt>pPacket</tt>.</li>
<li> <tt>flags</tt>: Reserved, set to zero.</li>
<li> <tt>pAddr</tt>: The
    <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> for the injected
    packet.</li>
<li> <tt>sendLen</tt>: The total number of bytes injected.
     Can be <tt>NULL</tt> if this information is not required.</li>
<li> <tt>lpOverlapped</tt>: An optional pointer to a <tt>OVERLAPPED</tt>
     structure.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if a packet was successfully injected, or <tt>FALSE</tt>
otherwise.
Use <tt>GetLastError()</tt> to get the reason.
The error code <tt>ERROR_IO_PENDING</tt> indicates that the overlapped
operation has been successfully initiated and that completion will be
indicated at a later time.
All other codes indicate an error.
</p><p>
<b>Remarks</b><br>
This function is equivalent to
<a href="#divert_send"><tt>WinDivertSend()</tt></a> except that it
supports overlapped I/O via the <tt>lpOverlapped</tt> parameter.
</p>
</dd></dl>

<a name="divert_shutdown"><h3>5.8 WinDivertShutdown</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertShutdown</b>(
    __in HANDLE handle,
    __in WINDIVERT_SHUTDOWN how);
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>how</tt>: A <tt>WINDIVERT_SHUTDOWN</tt> value to indicate how
     the handle should be shutdown.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
This operation causes all or part of a WinDivert handle to be shut down.
The possible values for <tt>how</tt> are:
</p>
<p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
How
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<tt>WINDIVERT_SHUTDOWN_RECV</tt>
</td>
<td>
Stop new packets being queued for
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_SHUTDOWN_SEND</tt>
</td>
<td>
Stop new packets being injected via
<a href="#divert_send"><tt>WinDivertSend()</tt></a>.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_SHUTDOWN_BOTH</tt>
</td>
<td>
Equivalent to <tt>(WINDIVERT_SHUTDOWN_RECV | WINDIVERT_SHUTDOWN_SEND)</tt>.
</td>
</tr>
</table>
</center>
</p>
<p>
Note that previously queued packets can still be received after
<tt>WINDIVERT_SHUTDOWN_RECV</tt>.
When the packet queue is empty,
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>
will fail with <tt>ERROR_NO_DATA</tt>.
</p>
</dd></dl>

<a name="divert_close"><h3>5.9 WinDivertClose</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertClose</b>(
    __in HANDLE handle
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Closes a WinDivert handle created by
<a href="#divert_open"><tt>WinDivertOpen()</tt></a>.
</p>
</dd></dl>

<a name="divert_set_param"><h3>5.10 WinDivertSetParam</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertSetParam</b>(
    __in HANDLE handle,
    __in WINDIVERT_PARAM param,
    __in UINT64 value);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>param</tt>: A WinDivert parameter name.</li>
<li> <tt>value</tt>: The parameter's new value.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Sets a WinDivert parameter.
Currently, the following WinDivert parameters are defined.
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Parameter
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<tt>WINDIVERT_PARAM_QUEUE_LEN</tt>
</td>
<td>
Sets the maximum length of the packet queue for
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
Currently the default value is 2048, the minimum is 16, and the maximum
is 16384.
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_PARAM_QUEUE_TIME</tt>
</td>
<td>
Sets the minimum time, in milliseconds, a packet can be queued before it is
automatically dropped.
Packets cannot be queued indefinitely, and ideally, packets should be
processed by the application as soon as is possible.
Note that this sets the <i>minimum</i> time a packet can be queued before 
it can be dropped.
The actual time may be exceed this value.
Currently the default value is 1000 (1s), the minimum is 20 (20ms), and the
maximum is 8000 (8s).
</td>
</tr>
<tr>
<td>
<tt>WINDIVERT_PARAM_QUEUE_SIZE</tt>
</td>
<td>
Sets the maximum number of bytes that can be stored in the packet queue for
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
Currently the default value is 4194304 (4MB), the minimum is 65535 (64KB),
and the maximum is 33554432 (32MB).
</td>
</tr>
</table>
</center>
</p>
</dd></dl>

<a name="divert_get_param"><h3>5.11 WinDivertGetParam</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertGetParam</b>(
    __in HANDLE handle,
    __in WINDIVERT_PARAM param,
    __out UINT64 *pValue);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>handle</tt>: A valid WinDivert handle created by
     <a href="#divert_open"><tt>WinDivertOpen()</tt></a>.</li>
<li> <tt>param</tt>: A WinDivert parameter name.</li>
<li> <tt>value</tt>: The parameter's current value.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Gets a WinDivert parameter.
See <a href="#divert_set_param"><tt>WinDivertSetParam()</tt></a> for the list
of parameters.
</p>
</dd></dl>

<hr>
<a name="helper_programming_api"><h2>6. Helper Programming API</h2></a>

The WinDivert helper programming API is a collection of definitions
and functions designed to make writing WinDivert applications easier.
The use of the helper API is completely optional.

<a name="divert_iphdr"><h3>6.1 WINDIVERT_IPHDR</h3>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT8  HdrLength:4;
    UINT8  Version:4;
    UINT8  TOS;
    UINT16 Length;
    UINT16 Id;
    UINT16 <i>...</i>;
    UINT8  TTL;
    UINT8  Protocol;
    UINT16 Checksum;
    UINT32 SrcAddr;
    UINT32 DstAddr;
} <b>WINDIVERT_IPHDR</b>, *<b>PWINDIVERT_IPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/IPv4#Packet_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
IPv4 header definition.
</p><p>
The following fields can only be get/set using the following macro
definitions:
<ul>
<li><i>FragOff</i> with <tt>WINDIVERT_IPHDR_GET_FRAGOFF(<i>hdr</i>)</tt> and
    <tt>WINDIVERT_IPHDR_SET_FRAGOFF(<i>hdr</i>, <i>val</i>)</tt></li>
<li><i>MF</i> with <tt>WINDIVERT_IPHDR_GET_MF(<i>hdr</i>)</tt> and
    <tt>WINDIVERT_IPHDR_SET_MF(<i>hdr</i>, <i>val</i>)</tt></li>
<li><i>DF</i> with <tt>WINDIVERT_IPHDR_GET_DF(<i>hdr</i>)</tt> and
    <tt>WINDIVERT_IPHDR_SET_DF(<i>hdr</i>, <i>val</i>)</tt></li>
<li><i>Reserved</i> with <tt>WINDIVERT_IPHDR_GET_RESERVED(<i>hdr</i>)</tt> and
    <tt>WINDIVERT_IPHDR_SET_RESERVED(<i>hdr</i>, <i>val</i>)</tt></li>
</ul>
</p>
</dl></dd>

<a name="divert_ipv6hdr"><h3>6.2 WINDIVERT_IPV6HDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT32 Version:4;
    UINT32 ...:28;
    UINT16 Length;
    UINT8  NextHdr;
    UINT8  HopLimit;
    UINT32 SrcAddr[4];
    UINT32 DstAddr[4];
} <b>WINDIVERT_IPV6HDR</b>, *<b>PWINDIVERT_IPV6HDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/IPv6_packet#Fixed_header">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
IPv6 header definition.
</p><p>
The following fields can only be get/set using the following macro
definitions:
<ul>
<li><i>TrafficClass</i> with
    <tt>WINDIVERT_IPV6HDR_GET_TRAFFICCLASS(<i>hdr</i>)</tt> and
    <tt>WINDIVERT_IPV6HDR_SET_TRAFFICCLASS(<i>hdr</i>, <i>val</i>)</tt></li>
<li><i>FlowLabel</i> with <tt>WINDIVERT_IPV6HDR_GET_FLOWLABEL(<i>hdr</i>)</tt> and
    <tt>WINDIVERT_IPV6HDR_SET_FLOWLABEL(<i>hdr</i>, <i>val</i>)</tt></li>
</ul>
</p>
</dl></dd>

<a name="divert_icmphdr"><h3>6.3 WINDIVERT_ICMPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT8  Type;
    UINT8  Code;
    UINT16 Checksum;
    UINT32 Body;
} <b>WINDIVERT_ICMPHDR</b>, *<b>PWINDIVERT_ICMPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#ICMP_segment_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
ICMP header definition.
</p>
</dl></dd>

<a name="divert_icmpv6hdr"><h3>6.4 WINDIVERT_ICMPV6HDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT8  Type;
    UINT8  Code;
    UINT16 Checksum;
    UINT32 Body;
} <b>WINDIVERT_ICMPV6HDR</b>, *<b>PWINDIVERT_ICMPV6HDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/ICMPv6#Packet_format">here</a> for
more information.
</p><p>
<b>Remarks</b><br>
ICMPv6 header definition.
</p>
</dl></dd>

<a name="divert_tcphdr"><h3>6.5 WINDIVERT_TCPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT16 SrcPort;
    UINT16 DstPort;
    UINT32 SeqNum;
    UINT32 AckNum;
    UINT16 Reserved1:4;
    UINT16 HdrLength:4;
    UINT16 Fin:1;
    UINT16 Syn:1;
    UINT16 Rst:1;
    UINT16 Psh:1;
    UINT16 Ack:1;
    UINT16 Urg:1;
    UINT16 Reserved2:2;
    UINT16 Window;
    UINT16 Checksum;
    UINT16 UrgPtr;
} <b>WINDIVERT_TCPHDR</b>, *<b>PWINDIVERT_TCPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
TCP header definition.
</p>
</dl></dd>

<a name="divert_udphdr"><h3>6.6 WINDIVERT_UDPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT16 SrcPort;
    UINT16 DstPort;
    UINT16 Length;
    UINT16 Checksum;
} <b>WINDIVERT_UDPHDR</b>, *<b>PWINDIVERT_UDPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
UDP header definition.
</p>
</dl></dd>

<a name="divert_helper_parse_packet"><h3>6.7 WinDivertHelperParsePacket</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperParsePacket</b>(
    __in PVOID pPacket,
    __in UINT packetLen,
    __out_opt PWINDIVERT_IPHDR *ppIpHdr,
    __out_opt PWINDIVERT_IPV6HDR *ppIpv6Hdr,
    __out_opt PWINDIVERT_ICMPHDR *ppIcmpHdr,
    __out_opt PWINDIVERT_ICMPV6HDR *ppIcmpv6Hdr,
    __out_opt PWINDIVERT_TCPHDR *ppTcpHdr,
    __out_opt PWINDIVERT_UDPHDR *ppUdpHdr,
    __out_opt PVOID *ppData,
    __out_opt UINT *pDataLen
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>pPacket</tt>: The packet to be parsed.</li>
<li> <tt>packetLen</tt>: The total length of the packet <tt>pPacket</tt>.</li>
<li> <tt>ppIpHdr</tt>: Output pointer to a <tt>WINDIVERT_IPHDR</tt>.</li>
<li> <tt>ppIpv6Hdr</tt>: Output pointer to a <tt>WINDIVERT_IPV6HDR</tt>.</li>
<li> <tt>ppIcmpHdr</tt>: Output pointer to a <tt>WINDIVERT_ICMPHDR</tt>.</li>
<li> <tt>ppIcmpv6Hdr</tt>: Output pointer to a <tt>WINDIVERT_ICMPV6HDR</tt>.</li>
<li> <tt>ppTcpHdr</tt>: Output pointer to a <tt>WINDIVERT_TCPHDR</tt>.</li>
<li> <tt>ppUdpHdr</tt>: Output pointer to a <tt>WINDIVERT_UDPHDR</tt>.</li>
<li> <tt>ppData</tt>: Output pointer to the packet's data/payload.</li>
<li> <tt>pDataLen</tt> Output data/payload length.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if all expected (non-<tt>NULL</tt>) outputs were present,
<tt>FALSE</tt> otherwise.
Note that <tt>FALSE</tt> may sometimes be a legitimate return value, e.g.,
when both <tt>ppIpHdr</tt> and <tt>ppIpv6Hdr</tt> are non-<tt>NULL</tt>.
</p><p>
<b>Remarks</b><br>
Parses a raw packet (e.g. from <a
href="#divert_recv"><tt>WinDivertRecv()</tt></a>) into the
various packet headers and/or payloads that may or may not be present.
</p><p>
Each output parameter may be <tt>NULL</tt> or non-<tt>NULL</tt>.
For non-<tt>NULL</tt> parameters, this function will write the pointer to
the corresponding header/payload if it exists, or will write <tt>NULL</tt>
otherwise.
Any non-<tt>NULL</tt> pointer that is returned
<ol>
<li> Is a pointer into the original <tt>pPacket</tt> packet; and</li>
<li> There is enough space in <tt>pPacket</tt> to fit the header.</li>
</ol>
</p><p>
This function does not do any verification of the header/payload contents
beyond checking the header length and any other minimal information required
for parsing.
<p>
</dd></dl>

<a name="divert_helper_hash_packet"><h3>6.8 WinDivertHelperHashPacket</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT64 <b>WinDivertHelperHashPacket</b>(
    __in const VOID *pPacket,
    __in UINT packetLen,
    __in UINT64 seed = 0
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>pPacket</tt>: The packet to be hashed.</li>
<li> <tt>packetLen</tt>: The total length of the packet <tt>pPacket</tt>.</li>
<li> <tt>seed</tt>: An optional seed value.</li>
</ul>
</p><p>
<b>Return Value</b><br>
A 64bit hash value.
</p><p>
<b>Remarks</b><br>
Calculates a 64bit hash value of the given packet.
Note that the hash function depends on the <i>packet's
IP and transport headers only</i>, and not the payload of the packet.
That said, a weak dependency on the payload will exist if the
TCP/UDP checksums are valid.
The hash function itself is based on the
<a href="https://cyan4973.github.io/xxHash/">xxHash</a> algorithm
and is <b>not</b> cryptographic.
</p><p>
The optional <tt>seed</tt> value is also incorporated into the hash.
<p>
</dd></dl>

<a name="divert_helper_parse_ipv4_address"><h3>6.9 WinDivertHelperParseIPv4Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperParseIPv4Address</b>(
    __in const char *addrStr,
    __out_opt UINT32 *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>addrStr</tt>: The address string.</li>
<li> <tt>pAddr</tt>: Output address.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Parses an IPv4 address stored in <tt>addrStr</tt>.
If <tt>pAddr</tt> is non-<tt>NULL</tt>, the result is be stored in
host-byte-order.
Use <a href="#divert_helper_hton"><tt>WinDivertHelperHtonl()</tt></a>
to convert the result into network-byte-order.
</p>
</dd></dl>

<a name="divert_helper_parse_ipv6_address"><h3>6.10 WinDivertHelperParseIPv6Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperParseIPv6Address</b>(
    __in const char *addrStr,
    __out_opt UINT32 *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>addrStr</tt>: The address string.</li>
<li> <tt>pAddr</tt>: Output address.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Parses an IPv6 address stored in <tt>addrStr</tt>.
If <tt>pAddr</tt> is non-<tt>NULL</tt>, the buffer assumed 
to be large enough to hold a 16-byte IPv6 address.
The result is stored in host-byte-order.
Use <a href="#divert_helper_hton"><tt>WinDivertHelperHtonIpv6Address()</tt></a>
to convert the result into network-byte-order.
</p>
</dd></dl>

<a name="divert_helper_format_ipv4_address"><h3>6.11 WinDivertHelperParseIPv4Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperFormatIPv4Address</b>(
    __in UINT32 addr,
    __out char *buffer,
    __in UINT bufLen
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>addr</tt>: The IPv4 address in host-byte order.</li>
<li> <tt>buffer</tt>: The buffer to store the formatted string.</li>
<li> <tt>bufLen</tt>: The length of <tt>buffer</tt>.
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Convert an IPv4 address into a string.
</p>
</dd></dl>

<a name="divert_helper_format_ipv6_address"><h3>6.12 WinDivertHelperParseIPv6Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperFormatIPv6Address</b>(
    __in const UINT32 *pAddr,
    __out char *buffer,
    __in UINT bufLen
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>pAddr</tt>: The IPv6 address in host-byte order.</li>
<li> <tt>buffer</tt>: The buffer to store the formatted string.</li>
<li> <tt>bufLen</tt>: The length of <tt>buffer</tt>.
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Convert an IPv6 address into a string.
</p>
</dd></dl>

<a name="divert_helper_calc_checksums"><h3>6.13 WinDivertHelperCalcChecksums</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT <b>WinDivertHelperCalcChecksums</b>(
    __inout PVOID pPacket,
    __in UINT packetLen,
    __in_opt PWINDIVERT_ADDRESS pAddr,
    __in UINT64 flags
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>pPacket</tt>: The packet to be modified.</li>
<li> <tt>packetLen</tt>: The total length of the packet <tt>pPacket</tt>.</li>
<li> <tt>pAddr</tt>: Optional pointer to a
    <a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> structure.</li>
<li> <tt>flags</tt>: One or more of the following flags:
<ul>
<li> <tt>WINDIVERT_HELPER_NO_IP_CHECKSUM</tt>: Do not calculate the IPv4
    checksum.</li>
<li> <tt>WINDIVERT_HELPER_NO_ICMP_CHECKSUM</tt>: Do not calculate the ICMP
    checksum.</li>
<li> <tt>WINDIVERT_HELPER_NO_ICMPV6_CHECKSUM</tt>: Do not calculate the ICMPv6
    checksum.</li>
<li> <tt>WINDIVERT_HELPER_NO_TCP_CHECKSUM</tt>: Do not calculate the TCP
    checksum.</li>
<li> <tt>WINDIVERT_HELPER_NO_UDP_CHECKSUM</tt>: Do not calculate the UDP
    checksum.</li>
</ul></li>
</ul>
</p><p>
<b>Return Value</b><br>
The number of checksums calculated.
</p><p>
<b>Remarks</b><br>
(Re)calculates the checksum for any IPv4/ICMP/ICMPv6/TCP/UDP checksum present
in the given packet.
Individual checksum calculations may be disabled via the appropriate flag.
Typically this function should be invoked on a modified packet before it is
injected with <a href="#divert_send"><tt>WinDivertSend()</tt></a>.
</p><p>
By default this function will calculate each checksum from scratch, even if
the existing checksum is correct.
This may be inefficient for some applications.
For better performance, incremental checksum calculations should be used
instead (not provided by this API).
</p><p>
If <tt>pAddr</tt> is non-<tt>NULL</tt>, this function will avoid calculating
the full checksum if the <tt>Pseudo*Checksum</tt> flag is
set in the corresponding
<a href="#divert_address"><tt>WINDIVERT_ADDRESS</tt></a> structure.
The address structure should be the same as
the one passed to <a href="#divert_send"><tt>WinDivertSend()</tt></a> in
order to (re)inject the packet.
</p>
</dd></dl>

<a name="divert_helper_compile_filter"><h3>6.14 WinDivertHelperCompileFilter</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperCompileFilter</b>(
    __in const char *filter,
    __in WINDIVERT_LAYER layer,
    __out_opt char *object,
    __in UINT objLen,
    __out_opt const char **errorStr,
    __out_opt UINT *errorPos
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>filter</tt>: The packet filter string to be checked.</li>
<li> <tt>layer</tt>: The layer.</li>
<li> <tt>object</tt>: The compiled filter object.</li>
<li> <tt>objLen</tt>: The length of the <tt>object</tt> buffer.</li>
<li> <tt>errorStr</tt>: The error description.</li>
<li> <tt>errorPos</tt>: The error position.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if the packet filter compilation is successful, <tt>FALSE</tt>
otherwise.
</p><p>
<b>Remarks</b><br>
Compiles the given packet filter string into a compact <q>object</q>
representation that is optionally stored in <tt>object</tt> if non-NULL.
The <q>object</q> representation is a valid null terminated C string, but is
otherwise opaque and not meant to be human readable.
The object representation can be passed to all WinDivert functions,
such as <a href="#divert_open"><tt>WinDivertOpen()</tt></a>, in place of the
human-readable filter string equivalent.
</p>
<p>
The compilation operation will succeed if the given filter string is
valid with respect to the
<a href="#filter_language">filter language</a>.
Otherwise, if the filter is invalid, then a human readable description of
the error is
returned by <tt>errorStr</tt> (if non-<tt>NULL</tt>), and the error's
position is returned by <tt>errorPos</tt> (if non-<tt>NULL</tt>).
</p><p>
Note that all strings returned through <tt>errorStr</tt> are global static
objects, and therefore do not need to be deallocated.
<p>
</dd></dl>

<a name="divert_helper_eval_filter"><h3>6.15 WinDivertHelperEvalFilter</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperEvalFilter</b>(
    __in const char *filter,
    __in PVOID pPacket,
    __in UINT packetLen,
    __in PWINDIVERT_ADDRESS pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>filter</tt>: The packet filter string to be evaluated.</li>
<li> <tt>pPacket</tt>: The packet.</li>
<li> <tt>packetLen</tt>: The total length of the packet <tt>pPacket</tt>.</li>
<li> <tt>pAddr</tt>: The <tt>WINDIVERT_ADDRESS</tt> of the packet
    <tt>pPacket</tt>.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if the packet matches the filter string,
    <tt>FALSE</tt> otherwise.
</p><p>
<b>Remarks</b><br>
Evaluates the given packet against the given packet filter string.
This function returns <tt>TRUE</tt> if the packet matches, and
returns <tt>FALSE</tt> otherwise.
</p><p>
This function also returns <tt>FALSE</tt> if an error occurs, in which
case <tt>GetLastError()</tt> can be used to get the reason for the error.
Otherwise, if no error occurred, <tt>GetLastError()</tt> will return
<tt>0</tt>.
</p><p>
Note that this function is relatively slow since the packet filter string
will be (re)compiled for each call.
This overhead can be minimized by pre-compiling the filter string into the
object representation using the
<a href="#divert_helper_compile_filter"><tt>WinDivertHelperCompileFilter()</tt></a>
function.
<p>
</dd></dl>

<a name="divert_helper_format_filter"><h3>6.16 WinDivertHelperFormatFilter</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperEvalFilter</b>(
    __in const char *filter,
    __in WINDIVERT_LAYER layer,
    __out char *buffer,
    __in UINT bufLen
);
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Parameters</b><br>
<ul>
<li> <tt>filter</tt>: The packet filter string to be evaluated.</li>
<li> <tt>layer</tt>: The layer.</li>
<li> <tt>buffer</tt>: A buffer for the formatted filter.</li>
<li> <tt>bufLen</tt>: The length of <tt>buffer</tt>.</li>
</ul>
</p><p>
<b>Return Value</b><br>
<tt>TRUE</tt> if successful, <tt>FALSE</tt> if an error occurred.
Use <tt>GetLastError()</tt> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Formats the given filter string or object.
This function is mainly useful for <q>decompiling</q> the filter object
representation back into a human-readable filter string representation.
One application is the <tt>WINDIVERT_LAYER_REFLECT</tt> layer,
where a pseudo packet containing a filter object is returned by
<a href="#divert_recv"><tt>WinDivertRecv()</tt></a>.
</p>
</dd></dl>

<a name="divert_helper_ntoh"><h3>6.17 WinDivertHelperNtoh*</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT16 <b>WinDivertHelperNtohs</b>(
    __in UINT16 x
);
UINT32 <b>WinDivertHelperNtohl</b>(
    __in UINT32 x
);
UINT64 <b>WinDivertHelperNtohll</b>(
    __in UINT64 x
);
void <b>WinDivertHelperNtohIpv6Address</b>(
    __in const UINT *inAddr,
    __out UINT *outAddr
);
</pre>
</td></tr></table>
<dl><dd>
<b>Parameters</b><br>
<ul>
<li> <tt>x</tt>: The input value in network byte-order.</li>
<li> <tt>inAddr</tt>: The input IPv6 address in network byte-order.</li>
<li> <tt>outAddr</tt>: A buffer for the output IPv6 address in host
	byte-order.</li>
</ul>
</p><p>
<b>Return Value</b><br>
The output value in host byte order.
</p><p>
<b>Remarks</b><br>
Converts a value/IPv6-address from network to host byte-order.
</p>
</dd></dl>

<a name="divert_helper_hton"><h3>6.18 WinDivertHelperHton*</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT16 <b>WinDivertHelperHtons</b>(
    __in UINT16 x
);
UINT32 <b>WinDivertHelperHtonl</b>(
    __in UINT32 x
);
UINT64 <b>WinDivertHelperHtonll</b>(
    __in UINT64 x
);
void <b>WinDivertHelperHtonIpv6Address</b>(
    __in const UINT *inAddr,
    __out UINT *outAddr
);
</pre>
</td></tr></table>
<dl><dd>
<b>Parameters</b><br>
<ul>
<li> <tt>x</tt>: The input value in host byte-order.</li>
<li> <tt>inAddr</tt>: The input IPv6 address in host byte-order.</li>
<li> <tt>outAddr</tt>: A buffer for the output IPv6 address in network
	byte-order.</li>
</ul>
</p><p>
<b>Return Value</b><br>
The output value in network byte order.
</p><p>
<b>Remarks</b><br>
Converts a value/IPv6-address from host to network byte-order.
</p>
</dd></dl>

<hr>
<a name="filter_language"><h2>7. Filter Language</h2></a>

<p>
The <a href="#divert_open"><tt>WinDivertOpen()</tt></a> function accepts a
string containing a <i>filter expression</i>.
Only packets that match the filter expression are diverted.
Any other packet is allowed to continue as per normal.
</p><p>
Filter allows an application to select only the subset of traffic that is of
interest.
For example, a URL blacklist filter would only be interested in packets that
contain URLs.
This could be achieved via the following filter.
<pre>
HANDLE handle = WinDivertOpen(
    "outbound and "
    "tcp.PayloadLength &gt; 0 and "
    "tcp.DstPort == 80", 0, 0, 0);
</pre>
This filter specifies that we should only divert traffic that is
<ol>
<li>outbound;</li>
<li>contains a non-empty payload; and</li>
<li>has TCP destination port 80 (i.e. HTTP web traffic).
</ol>
</p><p>
A <i>filter</i> is a Boolean expression of the form:
<pre>
        <i>FILTER</i> := true | false | <i>FILTER</i> and <i>FILTER</i> | <i>FILTER</i> or <i>FILTER</i> | (<i>FILTER</i>) | (<i>FILTER</i>? <i>FILTER</i>: <i>FILTER</i>) | <i>TEST</i>
</pre>
C-style syntax <tt>&amp;&amp;</tt>, <tt>||</tt>, and <tt>!</tt> may also
be used instead of <tt>and</tt>, <tt>or</tt>, and <tt>not</tt>, respectively.
C-style <i>conditional operators</i> are also supported,
where the expression <tt>(A? B: C)</tt> evaluates to:
<ul>
<li> <tt>B</tt> if <tt>A</tt> evaluates to <tt>true</tt>; or</li>
<li> <tt>C</tt> if <tt>A</tt> evaluates to <tt>false</tt>.
</ul>
A <i>test</i> is of the following form:
<pre>
        <i>TEST</i> := <i>TEST0</i> | not <i>TEST0</i>
        <i>TEST0</i> := <i>FIELD</i> | <i>FIELD</i> op <i>VAL</i>
</pre>
where <tt>op</tt> is one of the following:
</p><p>
<center>
<table border="1" cellpadding="5">
<tr><th>Operator</th><th>Description</th></tr>
<tr><td><tt>==</tt> or <tt>=</tt></td><td>Equal</td></tr>
<tr><td><tt>!=</tt></td><td>Not equal</td></tr>
<tr><td><tt>&lt;</tt></td><td>Less-than</td></tr>
<tr><td><tt>&gt;</tt></td><td>Greater-than</td></tr>
<tr><td><tt>&lt;=</tt></td><td>Less-than-or-equal</td></tr>
<tr><td><tt>&gt;=</tt></td><td>Greater-than-or-equal</td></tr>
</table>
</center>
</p><p>
and <tt><i>VAL</i></tt> is a decimal number, hexadecimal number, or IP
address.
If the "<tt>op <i>VAL</i></tt>" is missing, the test is implicitly
"<tt><i>FIELD</i> != 0</tt>".
</p><p>
Finally a <i>field</i> is some property about the packet.
The possible fields are:
</p><p>
<center>
<table border="1" cellpadding="5">
<tr><th>Field</th><th colspan="5">Layer</th><th>Description</th></tr>
<tr><th></th><th><tt>NETWORK</tt></th><th><tt>FORWARD</tt></th><th><tt>FLOW&nbsp;&nbsp;&nbsp;</tt></th><th><tt>SOCKET&nbsp;</tt></th><th><tt>REFLECT</tt></th><th></th></tr>
<tr><td><tt>zero</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>The value zero</td></tr>
<tr><td><tt>event</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>The event</td></tr>
<tr><td><tt>outbound</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td></td><td></td><td>Is outbound?</td></tr>
<tr><td><tt>inbound</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td></td><td></td><td>Is inbound?</td></tr>
<tr><td><tt>ifIdx</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Interface index</td></tr>
<tr><td><tt>subIfIdx</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Sub-interface index</td></tr>
<tr><td><tt>loopback</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is loopback packet?</td></tr>
<tr><td><tt>impostor</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Is impostor packet?</td></tr>
<tr><td><tt>processId</tt></td><td></td><td></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>Process ID</td></tr>
<tr><td><tt>random8</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>8-bit random number</td></tr>
<tr><td><tt>random16</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>16-bit random number</td></tr>
<tr><td><tt>random32</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>32-bit random number</td></tr>
<tr><td><tt>layer</tt></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td>The handle's layer</td></tr>
<tr><td><tt>priority</tt></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td>The handle's priority</td></tr>
<tr><td><tt>packet[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 8-bit word of the packet</td></tr>
<tr><td><tt>packet16[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 16-bit word of the packet</td></tr>
<tr><td><tt>packet32[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 32-bit word of the packet</td></tr>
<tr><td><tt>ip</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is IPv4?</td></tr>
<tr><td><tt>ipv6</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is IPv6?</td></tr>
<tr><td><tt>icmp</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is ICMP?</td></tr>
<tr><td><tt>icmpv6</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is ICMPv6?</td></tr>
<tr><td><tt>tcp</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is TCP?</td></tr>
<tr><td><tt>udp</tt></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is UDP?</td></tr>
<tr><td><tt>protocol</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The protocol</td></tr>
<tr><td><tt>localAddr</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The local address</td></tr>
<tr><td><tt>localPort</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The local port</td></tr>
<tr><td><tt>remoteAddr</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The remote address</td></tr>
<tr><td><tt>remotePort</tt></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The remote port</td></tr>
<tr><td><tt>ip.*</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>IPv4 fields (see <tt>WINDIVERT_IPHDR</tt>)</td></tr>
<tr><td><tt>ipv6.*</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>IPv6 fields (see <tt>WINDIVERT_IPV6HDR</tt>)</td></tr>
<tr><td><tt>icmp.*</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>ICMP fields (see <tt>WINDIVERT_ICMPHDR</tt>)</td></tr>
<tr><td><tt>icmpv6.*</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>ICMPV6 fields (see <tt>WINDIVERT_ICMPV6HDR</tt>)</td></tr>
<tr><td><tt>tcp.*</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>TCP fields (see <tt>WINDIVERT_TCPHDR</tt>)</td></tr>
<tr><td><tt>tcp.PayloadLength</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The TCP payload length</td></tr>
<tr><td><tt>tcp.Payload[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 8-bit word of the TCP payload</td></tr>
<tr><td><tt>tcp.Payload16[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 16-bit word of the TCP payload</td></tr>
<tr><td><tt>tcp.Payload32[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 32-bit word of the TCP payload</td></tr>
<tr><td><tt>udp.*</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>UDP fields (see <tt>WINDIVERT_UDPHDR</tt>)</td></tr>
<tr><td><tt>udp.PayloadLength</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The UDP payload length</td></tr>
<tr><td><tt>udp.Payload[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 8-bit word of the UDP payload</td></tr>
<tr><td><tt>udp.Payload16[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 16-bit word of the UDP payload</td></tr>
<tr><td><tt>udp.Payload32[i]</tt></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <tt>i</tt><sup>th</sup> 32-bit word of the UDP payload</td></tr>
</table>
</center>
</p><p>
A <i>test</i> also fails if the field is missing.
E.g. the test "<tt>tcp.DstPort == 80</tt>" will fail if the packet does not
contain a TCP header.
</p>

<a name="filter_examples"><h3>7.1 Filter Examples</h3></a>

<p>
<ol>
<li>
Divert all outbound (non-local) web traffic:
<pre>
HANDLE handle = WinDivertOpen(
        "outbound and !loopback and "
        "(tcp.DstPort == 80 or udp.DstPort == 53)",
        0, 0, 0
    );
</pre>
</li>
<li>
Divert all inbound TCP SYNs:
<pre>
HANDLE handle = WinDivertOpen(
        "inbound and "
        "tcp.Syn",
        0, 0, 0
    );
</pre>
</li>
<li>
Divert all traffic:
<pre>
HANDLE handle = WinDivertOpen("true", 0, 0, 0);
</pre>
</li>
<li>
Divert no traffic:
<pre>
HANDLE handle = WinDivertOpen("false", 0, 0, 0);
</pre>
This is useful for packet injection.
</ol>

<a name="filter_usage"><h3>7.2 Filter Usage</h3></a>

<p>
The purpose of the filter is to help applications select the subset of
all network traffic that the application is interested in.
Ideally the filter should be
<ol>
<li> As short as possible; and</li>
<li> As selective as possible.</li>
</ol>
For some applications these two objectives can conflict.
That is, a selective filter is not short, and a short filter is not selective.
For such applications the developer should experiment with different
filter configurations and carefully measure the performance impact to
find the optimal solution.
</p>

<hr>
<a name="samples"><h2>8. Samples</h2></a>

<p>
Some samples have been provided to demonstrate the WinDivert API.
The sample programs are:
<ul>
<li><tt>webfilter.exe</tt>: A simple URL blacklist filter.
    This program monitors outbound HTTP traffic.
    If it finds a URL request that matches the blacklist, it hijacks the
    TCP connection, reseting the connection at the server's end, and
    sending a simple block-page to the browser.
    The blacklist(s) are specified at the command-line.</li>
<li><tt>netdump.exe</tt>: A simple packet sniffer based on the
    WinDivert filter language.
    This program takes a filter specified at the command line, and prints
    information about any packet that matches the filter.
    This example uses WinDivert in "packet sniffing" mode, similar to
    <tt>winpcap</tt>.
    However, unlike <tt>winpcap</tt>, WinDivert can see local (loopback)
    packets.
<li><tt>netfilter.exe</tt>: A simple firewall based on the WinDivert
    filter language.
    This program takes a filter specified at the command line, and blocks
    any packet that matches the filter.
    It blocks TCP by sending a TCP reset, UDP by an ICMP message, and all
    other traffic it simply drops.
    This is similar to the Linux <tt>iptables</tt> command with the
    <tt>-j REJECT</tt> option.</li>
<li><tt>passthru.exe</tt>: A simple program that simply re-injects every
    packet it captures.
    This example is multi-threaded, where multiple threads are processing
    packets from a single handle.
    This example is useful for performance testing, and as a starting point
    for more interesting applications.</li>
<li><tt>streamdump.exe</tt>: A simple program that demonstrates how to
    handle streams using WinDivert.
    The basic idea is to divert outbound TCP connections to a local proxy
    server which can capture or manipulate the stream.
    The <tt>streamdump</tt> sample program also demonstrates usage of the
    <a href="#divert_recv_ex"><tt>WinDivertRecvEx()</tt></a> and
    <a href="#divert_send_ex"><tt>WinDivertSendEx()</tt></a> functions.</li>
</ul>
</p><p>
The samples are intended for educational purposes only, and are not
fully-featured applications.
</p><p>
The following basic template for a WinDivert application.
The basic idea is to open a WinDivert handle, then enter a
capture-modify-reinject loop:
<pre>
    HANDLE handle;          // WinDivert handle
    WINDIVERT_ADDRESS addr; // Packet address
    char packet[MAXBUF];    // Packet buffer
    UINT packetLen;

    handle = WinDivertOpen("...", 0, 0, 0);   // Open some filter
    if (handle == INVALID_HANDLE_VALUE)
    {
        // Handle error
        exit(1);
    }

    // Main capture-modify-inject loop:
    while (TRUE)
    {
        if (!WinDivertRecv(handle, packet, sizeof(packet), &amp;addr, &amp;packetLen))
        {
            // Handle recv error
            continue;
        }

        // Modify packet.

        WinDivertHelperCalcChecksums(packet, packetLen, &amp;addr, 0);
        if (!WinDivertSend(handle, packet, packetLen, &amp;addr, NULL))
        {
            // Handle send error
            continue;
        }
    }
</pre>
For applications that do not need to modify the packet, a better approach is
to open the WinDivert handle with the <tt>WINDIVERT_FLAG_SNIFF</tt> flag set,
and not re-inject the packet with
<a href="#divert_send"><tt>WinDivertSend()</tt></a>.
See the <tt>netdump.exe</tt> sample program for an example of this usage.
</p>

<hr>
<a name="known_issues"><h2>9. Known Issues</h2></a>

<p>
There are some limitations to the WinDivert package.
They are
<ul>
<li><i>Injecting inbound ICMP/ICMPv6 messages</i>:
    Calling <a href="#divert_send"><tt>WinDivertSend()</tt></a> will fail with
    an error for certain types of inbound ICMP/ICMPv6 messages.
    This is probably because the Windows TCP/IP stack does not handle
    such messages.
    Such errors are harmless and can be ignored.
    </li>
<li><i>The forward layer does not interact well with the Windows NAT</i>:
    It is not possible to block packets pre-NAT with WinDivert.
    As a general principle, you should not try and mix WinDivert at the
    forward layer with the Windows NAT implementation.
    </li>
<li><i>Re-injecting unmodified packets can lead to infinite loops</i>:
    If two or more Windows Filtering Platform (WFP) callout drivers
    (including WinDivert applications) block and inject unmodified copies of
    packets then this can lead to an infinite loop.
    If such a loop occurs, 
    <a href="#divert_send"><tt>WinDivertSend()</tt></a> will eventually fail
    with error <tt>ERROR_HOST_UNREACHABLE</tt>.
    Unfortunately, such errors are not easy to fix.
    Some crude solutions include: (1) removing the incompatible driver, or
    (2) ignoring all packets with <tt>ip.TTL</tt> or
    <tt>ipv6.HopLimit</tt> less than the Windows <tt>DefaultTTL</tt>
    registry value.
    See <a href="https://github.com/basil00/Divert/issues/41">
    GitHub issue #41</a> for more information.
    </li>
<li><i>WinDivert can cause the MSVC x86_64 debugger to deadlock</i>:
    The deadlock occurs because the debugger uses local sockets.
    Thus: the debugger pauses the WinDivert
    application, which stops packets from being processed, which 
    causes the debugger wait forever on input from a socket.
    The deadlock can be avoided by ignoring loopback traffic.
    See <a href="https://github.com/basil00/Divert/issues/26">
    GitHub issue #26</a> for more information.
    </li>
<li><i>WinDivert can cause packets to be out-of-order</i>:
    Simply running the <tt>passthru.exe</tt> sample program can cause
    packets to become out-of-order.
    This is not a bug, since there is no requirement for packets to
    remain in-order.
    However, this may affect other buggy software
    (e.g. some buggy NAT implementations)
    that incorrectly assume packets to be in-order.
    </li>
</ul>
</p>

<hr>
<a name="license"><h2>10. License</h2></a>
<p>
WinDivert is dual-licensed, and is available under the
<a href="http://www.gnu.org/licenses/lgpl-3.0.txt">GNU Lesser General
Public License (LGPL) Version 3</a> or the
<a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt">
GNU General Public License (GPL) Version 2</a>.
Please see the notices below:
</p>
<p>
<b>LGPL version 3</b>:
<pre>
WinDivert is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</pre>
</p>
<p>
<b>GPL version 2</b>:
<pre>
WinDivert is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</pre>
</p>
</body>
</html>
